From e33c03eb59fd40616e51097cd7aac37b290edca0 Mon Sep 17 00:00:00 2001
From: Mihails Strasuns <mihails.strasuns.contractor@sociomantic.com>
Date: Sun, 9 Apr 2017 16:01:14 +0200
Subject: [PATCH 20/21] WIP: rework how -profile=gc output is calculated

---
 src/core/internal/traits.d       |   1 +
 src/core/memory.d                |   2 +
 src/gc/gc.d                      |  12 ++
 src/gc/proxy.d                   |   9 ++
 src/rt/tracegc.d                 | 325 ++++++++++++++-------------------------
 test/profile/bothgc.log.exp      |   2 +-
 test/profile/myprofilegc.log.exp |   2 +-
 7 files changed, 140 insertions(+), 213 deletions(-)

diff --git a/src/core/internal/traits.d b/src/core/internal/traits.d
index 8142f90c..7b1b7bdf 100644
--- a/src/core/internal/traits.d
+++ b/src/core/internal/traits.d
@@ -187,3 +187,4 @@ template hasElaborateCopyConstructor(T...)
     else
         enum bool hasElaborateCopyConstructor = false;
 }
+
diff --git a/src/core/memory.d b/src/core/memory.d
index aaa75662..f83658a2 100644
--- a/src/core/memory.d
+++ b/src/core/memory.d
@@ -166,6 +166,8 @@ struct GC
         size_t usedSize;
         /// number of free bytes on the GC heap (might only get updated after a collection)
         size_t freeSize;
+        ///
+        size_t lastAllocSize;
     }
 
     /**
diff --git a/src/gc/gc.d b/src/gc/gc.d
index f810b650..eab44520 100644
--- a/src/gc/gc.d
+++ b/src/gc/gc.d
@@ -112,6 +112,7 @@ __gshared Duration recoverTime;
 __gshared Duration maxPauseTime;
 __gshared size_t numCollections;
 __gshared size_t maxPoolMemory;
+__gshared size_t lastAllocSize;
 
 __gshared long numMallocs;
 __gshared long numFrees;
@@ -272,6 +273,14 @@ final class GCMutex : Mutex
 
 struct GC
 {
+
+    void gc_resetLastAllocation() nothrow
+    {
+        gcLock.lock();
+        scope(exit) gcLock.unlock();
+        .lastAllocSize = 0;
+    }
+
     // For passing to debug code (not thread safe)
     __gshared size_t line;
     __gshared char*  file;
@@ -535,6 +544,7 @@ struct GC
             alloc_size = size;
         }
         gcx.log_malloc(p, size);
+        .lastAllocSize += alloc_size;
 
         return p;
     }
@@ -1327,6 +1337,7 @@ struct GC
 
         stats.usedSize -= freeListSize;
         stats.freeSize += freeListSize;
+        stats.lastAllocSize = .lastAllocSize;
     }
 }
 
@@ -3245,6 +3256,7 @@ unittest // bugzilla 14467
     assert(arr.capacity);
 }
 
+
 /* ============================ SENTINEL =============================== */
 
 
diff --git a/src/gc/proxy.d b/src/gc/proxy.d
index 091ba3d4..6bd06bb8 100644
--- a/src/gc/proxy.d
+++ b/src/gc/proxy.d
@@ -55,6 +55,7 @@ private
 
             BlkInfo function(void*) gc_query;
             core.memory.GC.Stats function() gc_stats;
+            void function() gc_resetLastAllocation;
 
             void function(void*) gc_addRoot;
             void function(void*, size_t, const TypeInfo ti) gc_addRange;
@@ -92,6 +93,7 @@ private
 
         pthis.gc_query = &gc_query;
         pthis.gc_stats = &gc_stats;
+        pthis.gc_resetLastAllocation = &gc_resetLastAllocation;
 
         pthis.gc_addRoot = &gc_addRoot;
         pthis.gc_addRange = &gc_addRange;
@@ -266,6 +268,13 @@ extern (C)
         return proxy.gc_stats();
     }
 
+    void gc_resetLastAllocation() nothrow
+    {
+        if( proxy is null )
+            return _gc.gc_resetLastAllocation();
+        return proxy.gc_resetLastAllocation();
+    }
+
     void gc_addRoot( void* p ) nothrow
     {
         if( proxy is null )
diff --git a/src/rt/tracegc.d b/src/rt/tracegc.d
index 8845dd9b..7aff7c4a 100644
--- a/src/rt/tracegc.d
+++ b/src/rt/tracegc.d
@@ -15,10 +15,6 @@ module rt.tracegc;
 
 // version = tracegc;
 
-import rt.profilegc;
-
-version (tracegc) import core.stdc.stdio;
-
 version (none)
 {
     // this exercises each function
@@ -88,243 +84,150 @@ extern (C) void[] _d_newarrayT(const TypeInfo ti, size_t length);
 extern (C) void[] _d_newarrayiT(const TypeInfo ti, size_t length);
 extern (C) void[] _d_newarraymTX(const TypeInfo ti, size_t[] dims);
 extern (C) void[] _d_newarraymiTX(const TypeInfo ti, size_t[] dims);
-extern (C) void* _d_newitemT(in TypeInfo _ti);
-extern (C) void* _d_newitemiT(in TypeInfo _ti);
-
-private string generatePrintf ( )
-{
-    version (tracegc)
-    {
-        return q{
-            printf("%s file = '%.*s' line = %d function = '%.*s'\n",
-                __FUNCTION__.ptr,
-                file.length, file.ptr,
-                line,
-                funcname.length, funcname.ptr
-                );
-        };
-    }
-    else
-        return "";
-}
-
-extern (C) Object _d_newclassTrace(string file, int line, string funcname, const ClassInfo ci)
-{
-    mixin(generatePrintf());
-    accumulate(file, line, funcname, ci.name, ci.initializer.length);
-    return _d_newclass(ci);
-}
-
-extern (C) void[] _d_newarrayTTrace(string file, int line, string funcname, const TypeInfo ti, size_t length)
-{
-    mixin(generatePrintf());
-    accumulate(file, line, funcname, ti.toString(), ti.tsize * length);
-    return _d_newarrayT(ti, length);
-}
-
-extern (C) void[] _d_newarrayiTTrace(string file, int line, string funcname, const TypeInfo ti, size_t length)
-{
-    mixin(generatePrintf());
-    accumulate(file, line, funcname, ti.toString(), ti.tsize * length);
-    return _d_newarrayiT(ti, length);
-}
-
-extern (C) void[] _d_newarraymTXTrace(string file, int line, string funcname, const TypeInfo ti, size_t[] dims)
-{
-    mixin(generatePrintf());
-    size_t n = 1;
-    foreach (dim; dims)
-        n *= dim;
-    accumulate(file, line, funcname, ti.toString(), ti.tsize * n);
-    return _d_newarraymTX(ti, dims);
-}
-
-extern (C) void[] _d_newarraymiTXTrace(string file, int line, string funcname, const TypeInfo ti, size_t[] dims)
-{
-    mixin(generatePrintf());
-    size_t n = 1;
-    foreach (dim; dims)
-        n *= dim;
-    accumulate(file, line, funcname, ti.toString(), ti.tsize * n);
-    return _d_newarraymiTX(ti, dims);
-}
-
-extern (C) void* _d_newitemTTrace(string file, int line, string funcname, in TypeInfo ti)
-{
-    mixin(generatePrintf());
-    accumulate(file, line, funcname, ti.toString(), ti.tsize);
-    return _d_newitemT(ti);
-}
-
-extern (C) void* _d_newitemiTTrace(string file, int line, string funcname, in TypeInfo ti)
-{
-    mixin(generatePrintf());
-    accumulate(file, line, funcname, ti.toString(), ti.tsize);
-    return _d_newitemiT(ti);
-}
-
-
+extern (C) void* _d_newitemT(in TypeInfo ti);
+extern (C) void* _d_newitemiT(in TypeInfo ti);
 extern (C) void _d_callfinalizer(void* p);
 extern (C) void _d_callinterfacefinalizer(void *p);
 extern (C) void _d_delclass(Object* p);
 extern (C) void _d_delinterface(void** p);
 extern (C) void _d_delstruct(void** p, TypeInfo_Struct inf);
-extern (C) void _d_delarray_t(void[]* p, const TypeInfo_Struct ti);
+extern (C) void _d_delarray_t(void[]* p, const TypeInfo_Struct _);
 extern (C) void _d_delmemory(void* *p);
+extern (C) byte[] _d_arraycatT(const TypeInfo ti, byte[] x, byte[] y);
+extern (C) void[] _d_arraycatnTX(const TypeInfo ti, byte[][] arrs);
+extern (C) void* _d_arrayliteralTX(const TypeInfo ti, size_t length);
+extern (C) void* _d_assocarrayliteralTX(const TypeInfo_AssociativeArray ti,
+    void[] keys, void[] vals);
+extern (C) void[] _d_arrayappendT(const TypeInfo ti, ref byte[] x, byte[] y);
+extern (C) byte[] _d_arrayappendcTX(const TypeInfo ti, ref byte[] px, size_t n);
+extern (C) void[] _d_arrayappendcd(ref byte[] x, dchar c);
+extern (C) void[] _d_arrayappendwd(ref byte[] x, dchar c);
+extern (C) void[] _d_arraysetlengthT(const TypeInfo ti, size_t newlength, void[]* p);
+extern (C) void[] _d_arraysetlengthiT(const TypeInfo ti, size_t newlength, void[]* p);
+extern (C) void* _d_allocmemory(size_t sz);
 
-extern (C) void _d_callfinalizerTrace(string file, int line, string funcname, void* p)
-{
-    mixin(generatePrintf());
-    _d_callfinalizer(p);
-}
-
-extern (C) void _d_callinterfacefinalizerTrace(string file, int line, string funcname, void *p)
-{
-    mixin(generatePrintf());
-    _d_callinterfacefinalizer(p);
-}
-
-extern (C) void _d_delclassTrace(string file, int line, string funcname, Object* p)
-{
-    mixin(generatePrintf());
-    _d_delclass(p);
-}
 
-extern (C) void _d_delinterfaceTrace(string file, int line, string funcname, void** p)
-{
-    mixin(generatePrintf());
-    _d_delinterface(p);
-}
 
-extern (C) void _d_delstructTrace(string file, int line, string funcname, void** p, TypeInfo_Struct inf)
-{
-    mixin(generatePrintf());
-    _d_delstruct(p, inf);
-}
+extern extern(C) void gc_resetLastAllocation();
+
+// Used as wrapper function body to get actual stats. Calling `original_func()`
+// will call wrapped function with all required arguments.
+//
+// Placed here as a separate string constant to simplify maintenance as it is
+// much more likely to be modified than rest of generation code.
+enum accumulator = q{
+    import rt.profilegc : accumulate;
+    import core.memory : GC;
+
+    static if (is(typeof(ci)))
+        string name = ci.name;
+    else static if (is(typeof(ti)))
+        string name = ti.toString();
+    else static if (__FUNCTION__ == "rt.tracegc._d_arrayappendcdTrace")
+        string name = "char[]";
+    else static if (__FUNCTION__ == "rt.tracegc._d_arrayappendwdTrace")
+        string name = "wchar[]";
+    else static if (__FUNCTION__ == "rt.tracegc._d_allocmemoryTrace")
+        string name = "closure";
+    else
+        string name = "";
 
-extern (C) void _d_delarray_tTrace(string file, int line, string funcname, void[]* p, const TypeInfo_Struct ti)
-{
-    mixin(generatePrintf());
-    _d_delarray_t(p, ti);
-}
+    version(tracegc)
+    {
+        import core.stdc.stdio;
+
+        printf("%s file = '%.*s' line = %d function = '%.*s' type = %.*s\n",
+            __FUNCTION__.ptr,
+            file.length, file.ptr,
+            line,
+            funcname.length, funcname.ptr,
+            name.length, name.ptr
+        );
+    }
+    gc_resetLastAllocation();
 
-extern (C) void _d_delmemoryTrace(string file, int line, string funcname, void* *p)
-{
-    mixin(generatePrintf());
-    _d_delmemory(p);
-}
+    scope(exit)
+    {
+        auto stats = GC.stats();
+        if (stats.lastAllocSize > 0)
+            accumulate(file, line, funcname, name, stats.lastAllocSize);
+    }
 
+    return original_func();
+};
 
-extern (C) void* _d_arrayliteralTX(const TypeInfo ti, size_t length);
-extern (C) void* _d_assocarrayliteralTX(const TypeInfo_AssociativeArray ti, void[] keys, void[] vals);
+mixin(generateTraceWrappers());
+//pragma(msg, generateTraceWrappers());
 
-extern (C) void* _d_arrayliteralTXTrace(string file, int line, string funcname, const TypeInfo ti, size_t length)
-{
-    mixin(generatePrintf());
-    accumulate(file, line, funcname, ti.toString(), ti.next.tsize * length);
-    return _d_arrayliteralTX(ti, length);
-}
+////////////////////////////////////////////////////////////////////////////////
+// code gen implementation
 
-extern (C) void* _d_assocarrayliteralTXTrace(string file, int line, string funcname,
-        const TypeInfo_AssociativeArray ti, void[] keys, void[] vals)
+private string generateTraceWrappers()
 {
-    mixin(generatePrintf());
-    accumulate(file, line, funcname, ti.toString(), (ti.key.tsize + ti.value.tsize) * keys.length);
-    return _d_assocarrayliteralTX(ti, keys, vals);
-}
-
+    string code;
 
+    foreach (name; __traits(allMembers, mixin(__MODULE__)))
+    {
+        static if (name.length > 3 && name[0..3] == "_d_")
+        {
+            mixin("alias Declaration = " ~ name ~ ";");
+            code ~= generateWrapper!Declaration();
+        }
+    }
 
-extern (C) byte[] _d_arraycatT(const TypeInfo ti, byte[] x, byte[] y);
-extern (C) void[] _d_arraycatnTX(const TypeInfo ti, byte[][] arrs);
-
-extern (C) byte[] _d_arraycatTTrace(string file, int line, string funcname, const TypeInfo ti, byte[] x, byte[] y)
-{
-    mixin(generatePrintf());
-    accumulate(file, line, funcname, ti.toString(), (x.length + y.length) * ti.next.tsize);
-    return _d_arraycatT(ti, x, y);
+    return code;
 }
 
-extern (C) void[] _d_arraycatnTXTrace(string file, int line, string funcname, const TypeInfo ti, byte[][] arrs)
+private string generateWrapper(alias Declaration)()
 {
-    mixin(generatePrintf());
-    size_t length;
-    foreach (b; arrs)
-        length += b.length;
-    accumulate(file, line, funcname, ti.toString(), length * ti.next.tsize);
-    return _d_arraycatnTX(ti, arrs);
-}
-
-extern (C) void[] _d_arrayappendT(const TypeInfo ti, ref byte[] x, byte[] y);
-extern (C) byte[] _d_arrayappendcTX(const TypeInfo ti, ref byte[] px, size_t n);
-extern (C) void[] _d_arrayappendcd(ref byte[] x, dchar c);
-extern (C) void[] _d_arrayappendwd(ref byte[] x, dchar c);
+    static size_t findParamIndex(string s)
+    {
+        assert (s[$-1] == ')');
+        size_t brackets = 1;
+        while (brackets != 0)
+        {
+            s = s[0 .. $-1];
+            if (s[$-1] == ')')
+                ++brackets;
+            if (s[$-1] == '(')
+                --brackets;
+        }
+
+        assert(s.length > 1);
+        return s.length - 1;
+    }
 
-extern (C) void[] _d_arrayappendTTrace(string file, int line, string funcname, const TypeInfo ti, ref byte[] x, byte[] y)
-{
-    mixin(generatePrintf());
-    accumulate(file, line, funcname, ti.toString(), ti.next.tsize * y.length);
-    return _d_arrayappendT(ti, x, y);
-}
+    auto type_string = typeof(Declaration).stringof;
+    auto name = __traits(identifier, Declaration);
+    auto param_idx = findParamIndex(type_string);
 
-extern (C) byte[] _d_arrayappendcTXTrace(string file, int line, string funcname, const TypeInfo ti, ref byte[] px, size_t n)
-{
-    mixin(generatePrintf());
-    accumulate(file, line, funcname, ti.toString(), ti.next.tsize * n);
-    return _d_arrayappendcTX(ti, px, n);
-}
+    auto new_declaration = type_string[0 .. param_idx] ~ " " ~ name
+        ~ "Trace(string file, int line, string funcname, "
+        ~ type_string[param_idx+1 .. $];
+    auto call_original = "    scope original_func = { return "
+        ~ __traits(identifier, Declaration) ~ "(" ~ Arguments!Declaration() ~ "); };";
 
-extern (C) void[] _d_arrayappendcdTrace(string file, int line, string funcname, ref byte[] x, dchar c)
-{
-    mixin(generatePrintf());
-    size_t n;
-    if (c <= 0x7F)
-        n = 1;
-    else if (c <= 0x7FF)
-        n = 2;
-    else if (c <= 0xFFFF)
-        n = 3;
-    else if (c <= 0x10FFFF)
-        n = 4;
-    else
-        assert(0);
-    accumulate(file, line, funcname, "char[]", n * char.sizeof);
-    return _d_arrayappendcd(x, c);
+    return new_declaration ~ "\n{\n" ~
+           call_original ~ "\n" ~
+           accumulator ~ "\n" ~
+           "}\n";
 }
 
-extern (C) void[] _d_arrayappendwdTrace(string file, int line, string funcname, ref byte[] x, dchar c)
+string Arguments(alias Func)()
 {
-    mixin(generatePrintf());
-    size_t n = 1 + (c > 0xFFFF);
-    accumulate(file, line, funcname, "wchar[]", n * wchar.sizeof);
-    return _d_arrayappendwd(x, c);
-}
+    string result = "";
 
-extern (C) void[] _d_arraysetlengthT(const TypeInfo ti, size_t newlength, void[]* p);
-extern (C) void[] _d_arraysetlengthiT(const TypeInfo ti, size_t newlength, void[]* p);
-
-extern (C) void[] _d_arraysetlengthTTrace(string file, int line, string funcname, const TypeInfo ti, size_t newlength, void[]* p)
-{
-    mixin(generatePrintf());
-    accumulate(file, line, funcname, ti.toString(), ti.next.tsize * newlength);
-    return _d_arraysetlengthT(ti, newlength, p);
-}
+    static if (is(typeof(Func) PT == __parameters))
+    {
+        foreach (idx, _; PT)
+            result ~= __traits(identifier, PT[idx .. idx + 1]) ~ ", ";
+    }
 
-extern (C) void[] _d_arraysetlengthiTTrace(string file, int line, string funcname, const TypeInfo ti, size_t newlength, void[]* p)
-{
-    mixin(generatePrintf());
-    accumulate(file, line, funcname, ti.toString(), ti.next.tsize * newlength);
-    return _d_arraysetlengthiT(ti, newlength, p);
+    return result;
 }
 
-
-extern (C) void* _d_allocmemory(size_t sz);
-
-extern (C) void* _d_allocmemoryTrace(string file, int line, string funcname, size_t sz)
+unittest
 {
-    mixin(generatePrintf());
-    accumulate(file, line, funcname, "closure", sz);
-    return _d_allocmemory(sz);
+    void foo(int x, double y) { }
+    static assert (Arguments!foo == "x, y, ");
 }
-
-
diff --git a/test/profile/bothgc.log.exp b/test/profile/bothgc.log.exp
index 6d389adb..884f24c2 100644
--- a/test/profile/bothgc.log.exp
+++ b/test/profile/bothgc.log.exp
@@ -1,2 +1,2 @@
 bytes allocated, allocations, type, function, file:line
-           4000	           1000	both.Num both.foo src/both.d:15
+          16000	           1000	both.Num both.foo src/both.d:15
diff --git a/test/profile/myprofilegc.log.exp b/test/profile/myprofilegc.log.exp
index f2337d8c..9d36ec54 100644
--- a/test/profile/myprofilegc.log.exp
+++ b/test/profile/myprofilegc.log.exp
@@ -1,2 +1,2 @@
 bytes allocated, allocations, type, function, file:line
-              4	              1	uint D main src/profilegc.d:6
+             16	              1	uint D main src/profilegc.d:6
-- 
2.15.0

